{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => {};\nexport default class RealtimeClient {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint, options) {\n    var _a;\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.eventsPerSecondLimitMs = 100;\n    this.inThrottle = false;\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    const eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n    if (eventsPerSecond) this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n      this.disconnect();\n      this.connect();\n    }), this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect() {\n    if (this.conn) {\n      return;\n    }\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer';\n      this.conn.onopen = () => this._onConnOpen();\n      this.conn.onerror = error => this._onConnError(error);\n      this.conn.onmessage = event => this._onConnMessage(event);\n      this.conn.onclose = event => this._onConnClose(event);\n    }\n  }\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code, reason) {\n    if (this.conn) {\n      this.conn.onclose = function () {}; // noop\n      if (code) {\n        this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n      } else {\n        this.conn.close();\n      }\n      this.conn = null;\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.reset();\n    }\n  }\n  /**\n   * Returns all created channels\n   */\n  getChannels() {\n    return this.channels;\n  }\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  removeChannel(channel) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const status = yield channel.unsubscribe();\n      if (this.channels.length === 0) {\n        this.disconnect();\n      }\n      return status;\n    });\n  }\n  /**\n   * Unsubscribes and removes all channels\n   */\n  removeAllChannels() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const values_1 = yield Promise.all(this.channels.map(channel => channel.unsubscribe()));\n      this.disconnect();\n      return values_1;\n    });\n  }\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n  channel(topic, params = {\n    config: {}\n  }) {\n    if (!this.isConnected()) {\n      this.connect();\n    }\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n    let callback = () => {\n      this.encode(data, result => {\n        var _a;\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n    if (this.isConnected()) {\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n        const isThrottled = this._throttle(callback)();\n        if (isThrottled) {\n          return 'rate limited';\n        }\n      } else {\n        callback();\n      }\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token) {\n    this.accessToken = token;\n    this.channels.forEach(channel => {\n      token && channel.updateJoinPayload({\n        access_token: token\n      });\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, {\n          access_token: token\n        });\n      }\n    });\n  }\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel) {\n    this.channels = this.channels.filter(c => c._joinRef() !== channel._joinRef());\n  }\n  /**\n   * Returns the URL of the websocket.\n   *\n   * @internal\n   */\n  _endPointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: VSN\n    }));\n  }\n  /** @internal */\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n      if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n        this.pendingHeartbeatRef = null;\n      }\n      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);\n      this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach(callback => callback(msg));\n    });\n  }\n  /** @internal */\n  _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`);\n    this._flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n    this.stateChangeCallbacks.open.forEach(callback => callback());\n  }\n  /** @internal */\n  _onConnClose(event) {\n    this.log('transport', 'close', event);\n    this._triggerChanError();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach(callback => callback(event));\n  }\n  /** @internal */\n  _onConnError(error) {\n    this.log('transport', error.message);\n    this._triggerChanError();\n    this.stateChangeCallbacks.error.forEach(callback => callback(error));\n  }\n  /** @internal */\n  _triggerChanError() {\n    this.channels.forEach(channel => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  /** @internal */\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  /** @internal */\n  _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  /** @internal */\n  _sendHeartbeat() {\n    var _a;\n    if (!this.isConnected()) {\n      return;\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n      return;\n    }\n    this.pendingHeartbeatRef = this._makeRef();\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    this.setAuth(this.accessToken);\n  }\n  /** @internal */\n  _throttle(callback, eventsPerSecondLimitMs = this.eventsPerSecondLimitMs) {\n    return () => {\n      if (this.inThrottle) return true;\n      callback();\n      if (eventsPerSecondLimitMs > 0) {\n        this.inThrottle = true;\n        setTimeout(() => {\n          this.inThrottle = false;\n        }, eventsPerSecondLimitMs);\n      }\n      return false;\n    };\n  }\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","w3cwebsocket","VSN","CHANNEL_EVENTS","TRANSPORTS","SOCKET_STATES","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","DEFAULT_HEADERS","CONNECTION_STATE","Timer","Serializer","RealtimeChannel","noop","RealtimeClient","constructor","endPoint","options","_a","accessToken","channels","headers","params","timeout","transport","heartbeatIntervalMs","heartbeatTimer","undefined","pendingHeartbeatRef","ref","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","eventsPerSecondLimitMs","inThrottle","websocket","Object","assign","eventsPerSecond","Math","floor","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","bind","reconnectTimer","disconnect","connect","_endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","event","_onConnMessage","onclose","_onConnClose","code","reason","clearInterval","reset","getChannels","removeChannel","channel","status","unsubscribe","length","removeAllChannels","values_1","all","map","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","topic","config","chan","push","send","includes","isThrottled","_throttle","setAuth","token","forEach","updateJoinPayload","access_token","joinedOnce","_isJoined","_push","_makeRef","newRef","toString","_leaveOpenTopic","dupChannel","find","c","_isJoining","_remove","filter","_joinRef","_appendParams","vsn","rawMessage","type","_isMember","_trigger","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","setTimeout"],"sources":["E:/green/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE, } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => { };\nexport default class RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket.\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     */\n    constructor(endPoint, options) {\n        var _a;\n        this.accessToken = null;\n        this.channels = [];\n        this.endPoint = '';\n        this.headers = DEFAULT_HEADERS;\n        this.params = {};\n        this.timeout = DEFAULT_TIMEOUT;\n        this.transport = w3cwebsocket;\n        this.heartbeatIntervalMs = 30000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.ref = 0;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new Serializer();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.eventsPerSecondLimitMs = 100;\n        this.inThrottle = false;\n        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers)\n            this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout)\n            this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if (options === null || options === void 0 ? void 0 : options.transport)\n            this.transport = options.transport;\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n            this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        const eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n        if (eventsPerSecond)\n            this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs)\n            ? options.reconnectAfterMs\n            : (tries) => {\n                return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n            };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode)\n            ? options.encode\n            : (payload, callback) => {\n                return callback(JSON.stringify(payload));\n            };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode)\n            ? options.decode\n            : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n            this.disconnect();\n            this.connect();\n        }), this.reconnectAfterMs);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        if (this.conn) {\n            return;\n        }\n        this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n        if (this.conn) {\n            this.conn.binaryType = 'arraybuffer';\n            this.conn.onopen = () => this._onConnOpen();\n            this.conn.onerror = (error) => this._onConnError(error);\n            this.conn.onmessage = (event) => this._onConnMessage(event);\n            this.conn.onclose = (event) => this._onConnClose(event);\n        }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        if (this.conn) {\n            this.conn.onclose = function () { }; // noop\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n            }\n            else {\n                this.conn.close();\n            }\n            this.conn = null;\n            // remove open handles\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.reconnectTimer.reset();\n        }\n    }\n    /**\n     * Returns all created channels\n     */\n    getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n    removeChannel(channel) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const status = yield channel.unsubscribe();\n            if (this.channels.length === 0) {\n                this.disconnect();\n            }\n            return status;\n        });\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n    removeAllChannels() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values_1 = yield Promise.all(this.channels.map((channel) => channel.unsubscribe()));\n            this.disconnect();\n            return values_1;\n        });\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case SOCKET_STATES.connecting:\n                return CONNECTION_STATE.Connecting;\n            case SOCKET_STATES.open:\n                return CONNECTION_STATE.Open;\n            case SOCKET_STATES.closing:\n                return CONNECTION_STATE.Closing;\n            default:\n                return CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    channel(topic, params = { config: {} }) {\n        if (!this.isConnected()) {\n            this.connect();\n        }\n        const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n        this.channels.push(chan);\n        return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        let callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n                const isThrottled = this._throttle(callback)();\n                if (isThrottled) {\n                    return 'rate limited';\n                }\n            }\n            else {\n                callback();\n            }\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n    setAuth(token) {\n        this.accessToken = token;\n        this.channels.forEach((channel) => {\n            token && channel.updateJoinPayload({ access_token: token });\n            if (channel.joinedOnce && channel._isJoined()) {\n                channel._push(CHANNEL_EVENTS.access_token, { access_token: token });\n            }\n        });\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n    _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n    _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n    _remove(channel) {\n        this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());\n    }\n    /**\n     * Returns the URL of the websocket.\n     *\n     * @internal\n     */\n    _endPointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n    }\n    /** @internal */\n    _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            let { topic, event, payload, ref } = msg;\n            if ((ref && ref === this.pendingHeartbeatRef) ||\n                event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n                this.pendingHeartbeatRef = null;\n            }\n            this.log('receive', `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`, payload);\n            this.channels\n                .filter((channel) => channel._isMember(topic))\n                .forEach((channel) => channel._trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n        });\n    }\n    /** @internal */\n    _onConnOpen() {\n        this.log('transport', `connected to ${this._endPointURL()}`);\n        this._flushSendBuffer();\n        this.reconnectTimer.reset();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n        this.stateChangeCallbacks.open.forEach((callback) => callback());\n    }\n    /** @internal */\n    _onConnClose(event) {\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n    }\n    /** @internal */\n    _onConnError(error) {\n        this.log('transport', error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n    }\n    /** @internal */\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));\n    }\n    /** @internal */\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    /** @internal */\n    _flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    /** @internal */\n    _sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            return;\n        }\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n            return;\n        }\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        this.setAuth(this.accessToken);\n    }\n    /** @internal */\n    _throttle(callback, eventsPerSecondLimitMs = this.eventsPerSecondLimitMs) {\n        return () => {\n            if (this.inThrottle)\n                return true;\n            callback();\n            if (eventsPerSecondLimitMs > 0) {\n                this.inThrottle = true;\n                setTimeout(() => {\n                    this.inThrottle = false;\n                }, eventsPerSecondLimitMs);\n            }\n            return false;\n        };\n    }\n}\n"],"mappings":"AAAA,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAK,UAAUC,OAAO,EAAEC,UAAU,EAAEC,CAAC,EAAEC,SAAS,EAAE;EACrF,SAASC,KAAKA,CAACC,KAAK,EAAE;IAAE,OAAOA,KAAK,YAAYH,CAAC,GAAGG,KAAK,GAAG,IAAIH,CAAC,CAAC,UAAUI,OAAO,EAAE;MAAEA,OAAO,CAACD,KAAK,CAAC;IAAE,CAAC,CAAC;EAAE;EAC3G,OAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAO,CAAC,EAAE,UAAUD,OAAO,EAAEE,MAAM,EAAE;IACvD,SAASC,SAASA,CAACJ,KAAK,EAAE;MAAE,IAAI;QAAEK,IAAI,CAACP,SAAS,CAACQ,IAAI,CAACN,KAAK,CAAC,CAAC;MAAE,CAAC,CAAC,OAAOO,CAAC,EAAE;QAAEJ,MAAM,CAACI,CAAC,CAAC;MAAE;IAAE;IAC1F,SAASC,QAAQA,CAACR,KAAK,EAAE;MAAE,IAAI;QAAEK,IAAI,CAACP,SAAS,CAAC,OAAO,CAAC,CAACE,KAAK,CAAC,CAAC;MAAE,CAAC,CAAC,OAAOO,CAAC,EAAE;QAAEJ,MAAM,CAACI,CAAC,CAAC;MAAE;IAAE;IAC7F,SAASF,IAAIA,CAACI,MAAM,EAAE;MAAEA,MAAM,CAACC,IAAI,GAAGT,OAAO,CAACQ,MAAM,CAACT,KAAK,CAAC,GAAGD,KAAK,CAACU,MAAM,CAACT,KAAK,CAAC,CAACW,IAAI,CAACP,SAAS,EAAEI,QAAQ,CAAC;IAAE;IAC7GH,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAK,CAACjB,OAAO,EAAEC,UAAU,IAAI,EAAE,CAAC,EAAEU,IAAI,CAAC,CAAC,CAAC;EACzE,CAAC,CAAC;AACN,CAAC;AACD,SAASO,YAAY,QAAQ,WAAW;AACxC,SAASC,GAAG,EAAEC,cAAc,EAAEC,UAAU,EAAEC,aAAa,EAAEC,eAAe,EAAEC,eAAe,EAAEC,eAAe,EAAEC,gBAAgB,QAAS,iBAAiB;AACtJ,OAAOC,KAAK,MAAM,aAAa;AAC/B,OAAOC,UAAU,MAAM,kBAAkB;AACzC,OAAOC,eAAe,MAAM,mBAAmB;AAC/C,MAAMC,IAAI,GAAGA,CAAA,KAAM,CAAE,CAAC;AACtB,eAAe,MAAMC,cAAc,CAAC;EAChC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAACC,QAAQ,EAAEC,OAAO,EAAE;IAC3B,IAAIC,EAAE;IACN,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACJ,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACK,OAAO,GAAGb,eAAe;IAC9B,IAAI,CAACc,MAAM,GAAG,CAAC,CAAC;IAChB,IAAI,CAACC,OAAO,GAAGjB,eAAe;IAC9B,IAAI,CAACkB,SAAS,GAAGvB,YAAY;IAC7B,IAAI,CAACwB,mBAAmB,GAAG,KAAK;IAChC,IAAI,CAACC,cAAc,GAAGC,SAAS;IAC/B,IAAI,CAACC,mBAAmB,GAAG,IAAI;IAC/B,IAAI,CAACC,GAAG,GAAG,CAAC;IACZ,IAAI,CAACC,MAAM,GAAGjB,IAAI;IAClB,IAAI,CAACkB,IAAI,GAAG,IAAI;IAChB,IAAI,CAACC,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,UAAU,GAAG,IAAItB,UAAU,CAAC,CAAC;IAClC,IAAI,CAACuB,oBAAoB,GAAG;MACxBC,IAAI,EAAE,EAAE;MACRC,KAAK,EAAE,EAAE;MACTC,KAAK,EAAE,EAAE;MACTC,OAAO,EAAE;IACb,CAAC;IACD,IAAI,CAACC,sBAAsB,GAAG,GAAG;IACjC,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB,IAAI,CAACxB,QAAQ,GAAI,GAAEA,QAAS,IAAGZ,UAAU,CAACqC,SAAU,EAAC;IACrD,IAAIxB,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACK,MAAM,EAChE,IAAI,CAACA,MAAM,GAAGL,OAAO,CAACK,MAAM;IAChC,IAAIL,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACI,OAAO,EACjE,IAAI,CAACA,OAAO,GAAGqB,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACtB,OAAO,CAAC,EAAEJ,OAAO,CAACI,OAAO,CAAC;IAClF,IAAIJ,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACM,OAAO,EACjE,IAAI,CAACA,OAAO,GAAGN,OAAO,CAACM,OAAO;IAClC,IAAIN,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACa,MAAM,EAChE,IAAI,CAACA,MAAM,GAAGb,OAAO,CAACa,MAAM;IAChC,IAAIb,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACO,SAAS,EACnE,IAAI,CAACA,SAAS,GAAGP,OAAO,CAACO,SAAS;IACtC,IAAIP,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACQ,mBAAmB,EAC7E,IAAI,CAACA,mBAAmB,GAAGR,OAAO,CAACQ,mBAAmB;IAC1D,MAAMmB,eAAe,GAAG,CAAC1B,EAAE,GAAGD,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACK,MAAM,MAAM,IAAI,IAAIJ,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC0B,eAAe;IACvJ,IAAIA,eAAe,EACf,IAAI,CAACL,sBAAsB,GAAGM,IAAI,CAACC,KAAK,CAAC,IAAI,GAAGF,eAAe,CAAC;IACpE,IAAI,CAACG,gBAAgB,GAAG,CAAC9B,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC8B,gBAAgB,IAC7F9B,OAAO,CAAC8B,gBAAgB,GACvBC,KAAK,IAAK;MACT,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAACA,KAAK,GAAG,CAAC,CAAC,IAAI,KAAK;IACxD,CAAC;IACL,IAAI,CAACC,MAAM,GAAG,CAAChC,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACgC,MAAM,IACzEhC,OAAO,CAACgC,MAAM,GACd,CAACC,OAAO,EAAEC,QAAQ,KAAK;MACrB,OAAOA,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACH,OAAO,CAAC,CAAC;IAC5C,CAAC;IACL,IAAI,CAACI,MAAM,GAAG,CAACrC,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACqC,MAAM,IACzErC,OAAO,CAACqC,MAAM,GACd,IAAI,CAACrB,UAAU,CAACqB,MAAM,CAACC,IAAI,CAAC,IAAI,CAACtB,UAAU,CAAC;IAClD,IAAI,CAACuB,cAAc,GAAG,IAAI9C,KAAK,CAAC,MAAM5B,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;MAC/E,IAAI,CAAC2E,UAAU,CAAC,CAAC;MACjB,IAAI,CAACC,OAAO,CAAC,CAAC;IAClB,CAAC,CAAC,EAAE,IAAI,CAACX,gBAAgB,CAAC;EAC9B;EACA;AACJ;AACA;EACIW,OAAOA,CAAA,EAAG;IACN,IAAI,IAAI,CAAC3B,IAAI,EAAE;MACX;IACJ;IACA,IAAI,CAACA,IAAI,GAAG,IAAI,IAAI,CAACP,SAAS,CAAC,IAAI,CAACmC,YAAY,CAAC,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,CAACtC,OAAO,CAAC;IAC3E,IAAI,IAAI,CAACU,IAAI,EAAE;MACX,IAAI,CAACA,IAAI,CAAC6B,UAAU,GAAG,aAAa;MACpC,IAAI,CAAC7B,IAAI,CAAC8B,MAAM,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC,CAAC;MAC3C,IAAI,CAAC/B,IAAI,CAACgC,OAAO,GAAI1B,KAAK,IAAK,IAAI,CAAC2B,YAAY,CAAC3B,KAAK,CAAC;MACvD,IAAI,CAACN,IAAI,CAACkC,SAAS,GAAIC,KAAK,IAAK,IAAI,CAACC,cAAc,CAACD,KAAK,CAAC;MAC3D,IAAI,CAACnC,IAAI,CAACqC,OAAO,GAAIF,KAAK,IAAK,IAAI,CAACG,YAAY,CAACH,KAAK,CAAC;IAC3D;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACIT,UAAUA,CAACa,IAAI,EAAEC,MAAM,EAAE;IACrB,IAAI,IAAI,CAACxC,IAAI,EAAE;MACX,IAAI,CAACA,IAAI,CAACqC,OAAO,GAAG,YAAY,CAAE,CAAC,CAAC,CAAC;MACrC,IAAIE,IAAI,EAAE;QACN,IAAI,CAACvC,IAAI,CAACK,KAAK,CAACkC,IAAI,EAAEC,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAGA,MAAM,GAAG,EAAE,CAAC;MAC7E,CAAC,MACI;QACD,IAAI,CAACxC,IAAI,CAACK,KAAK,CAAC,CAAC;MACrB;MACA,IAAI,CAACL,IAAI,GAAG,IAAI;MAChB;MACA,IAAI,CAACL,cAAc,IAAI8C,aAAa,CAAC,IAAI,CAAC9C,cAAc,CAAC;MACzD,IAAI,CAAC8B,cAAc,CAACiB,KAAK,CAAC,CAAC;IAC/B;EACJ;EACA;AACJ;AACA;EACIC,WAAWA,CAAA,EAAG;IACV,OAAO,IAAI,CAACtD,QAAQ;EACxB;EACA;AACJ;AACA;AACA;EACIuD,aAAaA,CAACC,OAAO,EAAE;IACnB,OAAO9F,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;MAChD,MAAM+F,MAAM,GAAG,MAAMD,OAAO,CAACE,WAAW,CAAC,CAAC;MAC1C,IAAI,IAAI,CAAC1D,QAAQ,CAAC2D,MAAM,KAAK,CAAC,EAAE;QAC5B,IAAI,CAACtB,UAAU,CAAC,CAAC;MACrB;MACA,OAAOoB,MAAM;IACjB,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACIG,iBAAiBA,CAAA,EAAG;IAChB,OAAOlG,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;MAChD,MAAMmG,QAAQ,GAAG,MAAM3F,OAAO,CAAC4F,GAAG,CAAC,IAAI,CAAC9D,QAAQ,CAAC+D,GAAG,CAAEP,OAAO,IAAKA,OAAO,CAACE,WAAW,CAAC,CAAC,CAAC,CAAC;MACzF,IAAI,CAACrB,UAAU,CAAC,CAAC;MACjB,OAAOwB,QAAQ;IACnB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;EACIG,GAAGA,CAACC,IAAI,EAAEC,GAAG,EAAEC,IAAI,EAAE;IACjB,IAAI,CAACzD,MAAM,CAACuD,IAAI,EAAEC,GAAG,EAAEC,IAAI,CAAC;EAChC;EACA;AACJ;AACA;EACIC,eAAeA,CAAA,EAAG;IACd,QAAQ,IAAI,CAACzD,IAAI,IAAI,IAAI,CAACA,IAAI,CAAC0D,UAAU;MACrC,KAAKpF,aAAa,CAACqF,UAAU;QACzB,OAAOjF,gBAAgB,CAACkF,UAAU;MACtC,KAAKtF,aAAa,CAAC8B,IAAI;QACnB,OAAO1B,gBAAgB,CAACmF,IAAI;MAChC,KAAKvF,aAAa,CAACwF,OAAO;QACtB,OAAOpF,gBAAgB,CAACqF,OAAO;MACnC;QACI,OAAOrF,gBAAgB,CAACsF,MAAM;IACtC;EACJ;EACA;AACJ;AACA;EACIC,WAAWA,CAAA,EAAG;IACV,OAAO,IAAI,CAACR,eAAe,CAAC,CAAC,KAAK/E,gBAAgB,CAACmF,IAAI;EAC3D;EACAhB,OAAOA,CAACqB,KAAK,EAAE3E,MAAM,GAAG;IAAE4E,MAAM,EAAE,CAAC;EAAE,CAAC,EAAE;IACpC,IAAI,CAAC,IAAI,CAACF,WAAW,CAAC,CAAC,EAAE;MACrB,IAAI,CAACtC,OAAO,CAAC,CAAC;IAClB;IACA,MAAMyC,IAAI,GAAG,IAAIvF,eAAe,CAAE,YAAWqF,KAAM,EAAC,EAAE3E,MAAM,EAAE,IAAI,CAAC;IACnE,IAAI,CAACF,QAAQ,CAACgF,IAAI,CAACD,IAAI,CAAC;IACxB,OAAOA,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;EACIC,IAAIA,CAACb,IAAI,EAAE;IACP,MAAM;MAAEU,KAAK;MAAE/B,KAAK;MAAEhB,OAAO;MAAErB;IAAI,CAAC,GAAG0D,IAAI;IAC3C,IAAIpC,QAAQ,GAAGA,CAAA,KAAM;MACjB,IAAI,CAACF,MAAM,CAACsC,IAAI,EAAG1F,MAAM,IAAK;QAC1B,IAAIqB,EAAE;QACN,CAACA,EAAE,GAAG,IAAI,CAACa,IAAI,MAAM,IAAI,IAAIb,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACmF,IAAI,CAACxG,MAAM,CAAC;MACzE,CAAC,CAAC;IACN,CAAC;IACD,IAAI,CAACuF,GAAG,CAAC,MAAM,EAAG,GAAEa,KAAM,IAAG/B,KAAM,KAAIrC,GAAI,GAAE,EAAEqB,OAAO,CAAC;IACvD,IAAI,IAAI,CAAC8C,WAAW,CAAC,CAAC,EAAE;MACpB,IAAI,CAAC,WAAW,EAAE,UAAU,EAAE,kBAAkB,CAAC,CAACM,QAAQ,CAACpC,KAAK,CAAC,EAAE;QAC/D,MAAMqC,WAAW,GAAG,IAAI,CAACC,SAAS,CAACrD,QAAQ,CAAC,CAAC,CAAC;QAC9C,IAAIoD,WAAW,EAAE;UACb,OAAO,cAAc;QACzB;MACJ,CAAC,MACI;QACDpD,QAAQ,CAAC,CAAC;MACd;IACJ,CAAC,MACI;MACD,IAAI,CAACnB,UAAU,CAACoE,IAAI,CAACjD,QAAQ,CAAC;IAClC;EACJ;EACA;AACJ;AACA;AACA;AACA;EACIsD,OAAOA,CAACC,KAAK,EAAE;IACX,IAAI,CAACvF,WAAW,GAAGuF,KAAK;IACxB,IAAI,CAACtF,QAAQ,CAACuF,OAAO,CAAE/B,OAAO,IAAK;MAC/B8B,KAAK,IAAI9B,OAAO,CAACgC,iBAAiB,CAAC;QAAEC,YAAY,EAAEH;MAAM,CAAC,CAAC;MAC3D,IAAI9B,OAAO,CAACkC,UAAU,IAAIlC,OAAO,CAACmC,SAAS,CAAC,CAAC,EAAE;QAC3CnC,OAAO,CAACoC,KAAK,CAAC7G,cAAc,CAAC0G,YAAY,EAAE;UAAEA,YAAY,EAAEH;QAAM,CAAC,CAAC;MACvE;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;EACIO,QAAQA,CAAA,EAAG;IACP,IAAIC,MAAM,GAAG,IAAI,CAACrF,GAAG,GAAG,CAAC;IACzB,IAAIqF,MAAM,KAAK,IAAI,CAACrF,GAAG,EAAE;MACrB,IAAI,CAACA,GAAG,GAAG,CAAC;IAChB,CAAC,MACI;MACD,IAAI,CAACA,GAAG,GAAGqF,MAAM;IACrB;IACA,OAAO,IAAI,CAACrF,GAAG,CAACsF,QAAQ,CAAC,CAAC;EAC9B;EACA;AACJ;AACA;AACA;AACA;EACIC,eAAeA,CAACnB,KAAK,EAAE;IACnB,IAAIoB,UAAU,GAAG,IAAI,CAACjG,QAAQ,CAACkG,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAACtB,KAAK,KAAKA,KAAK,KAAKsB,CAAC,CAACR,SAAS,CAAC,CAAC,IAAIQ,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC;IAClG,IAAIH,UAAU,EAAE;MACZ,IAAI,CAACjC,GAAG,CAAC,WAAW,EAAG,4BAA2Ba,KAAM,GAAE,CAAC;MAC3DoB,UAAU,CAACvC,WAAW,CAAC,CAAC;IAC5B;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI2C,OAAOA,CAAC7C,OAAO,EAAE;IACb,IAAI,CAACxD,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACsG,MAAM,CAAEH,CAAC,IAAKA,CAAC,CAACI,QAAQ,CAAC,CAAC,KAAK/C,OAAO,CAAC+C,QAAQ,CAAC,CAAC,CAAC;EACpF;EACA;AACJ;AACA;AACA;AACA;EACIhE,YAAYA,CAAA,EAAG;IACX,OAAO,IAAI,CAACiE,aAAa,CAAC,IAAI,CAAC5G,QAAQ,EAAE0B,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACrB,MAAM,EAAE;MAAEuG,GAAG,EAAE3H;IAAI,CAAC,CAAC,CAAC;EAC1F;EACA;EACAiE,cAAcA,CAAC2D,UAAU,EAAE;IACvB,IAAI,CAACxE,MAAM,CAACwE,UAAU,CAACvC,IAAI,EAAGD,GAAG,IAAK;MAClC,IAAI;QAAEW,KAAK;QAAE/B,KAAK;QAAEhB,OAAO;QAAErB;MAAI,CAAC,GAAGyD,GAAG;MACxC,IAAKzD,GAAG,IAAIA,GAAG,KAAK,IAAI,CAACD,mBAAmB,IACxCsC,KAAK,MAAMhB,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC6E,IAAI,CAAC,EAAE;QAC5E,IAAI,CAACnG,mBAAmB,GAAG,IAAI;MACnC;MACA,IAAI,CAACwD,GAAG,CAAC,SAAS,EAAG,GAAElC,OAAO,CAAC2B,MAAM,IAAI,EAAG,IAAGoB,KAAM,IAAG/B,KAAM,IAAIrC,GAAG,IAAI,GAAG,GAAGA,GAAG,GAAG,GAAG,IAAK,EAAG,EAAC,EAAEqB,OAAO,CAAC;MAC3G,IAAI,CAAC9B,QAAQ,CACRsG,MAAM,CAAE9C,OAAO,IAAKA,OAAO,CAACoD,SAAS,CAAC/B,KAAK,CAAC,CAAC,CAC7CU,OAAO,CAAE/B,OAAO,IAAKA,OAAO,CAACqD,QAAQ,CAAC/D,KAAK,EAAEhB,OAAO,EAAErB,GAAG,CAAC,CAAC;MAChE,IAAI,CAACK,oBAAoB,CAACI,OAAO,CAACqE,OAAO,CAAExD,QAAQ,IAAKA,QAAQ,CAACmC,GAAG,CAAC,CAAC;IAC1E,CAAC,CAAC;EACN;EACA;EACAxB,WAAWA,CAAA,EAAG;IACV,IAAI,CAACsB,GAAG,CAAC,WAAW,EAAG,gBAAe,IAAI,CAACzB,YAAY,CAAC,CAAE,EAAC,CAAC;IAC5D,IAAI,CAACuE,gBAAgB,CAAC,CAAC;IACvB,IAAI,CAAC1E,cAAc,CAACiB,KAAK,CAAC,CAAC;IAC3B,IAAI,CAAC/C,cAAc,IAAI8C,aAAa,CAAC,IAAI,CAAC9C,cAAc,CAAC;IACzD,IAAI,CAACA,cAAc,GAAGyG,WAAW,CAAC,MAAM,IAAI,CAACC,cAAc,CAAC,CAAC,EAAE,IAAI,CAAC3G,mBAAmB,CAAC;IACxF,IAAI,CAACS,oBAAoB,CAACC,IAAI,CAACwE,OAAO,CAAExD,QAAQ,IAAKA,QAAQ,CAAC,CAAC,CAAC;EACpE;EACA;EACAkB,YAAYA,CAACH,KAAK,EAAE;IAChB,IAAI,CAACkB,GAAG,CAAC,WAAW,EAAE,OAAO,EAAElB,KAAK,CAAC;IACrC,IAAI,CAACmE,iBAAiB,CAAC,CAAC;IACxB,IAAI,CAAC3G,cAAc,IAAI8C,aAAa,CAAC,IAAI,CAAC9C,cAAc,CAAC;IACzD,IAAI,CAAC8B,cAAc,CAAC8E,eAAe,CAAC,CAAC;IACrC,IAAI,CAACpG,oBAAoB,CAACE,KAAK,CAACuE,OAAO,CAAExD,QAAQ,IAAKA,QAAQ,CAACe,KAAK,CAAC,CAAC;EAC1E;EACA;EACAF,YAAYA,CAAC3B,KAAK,EAAE;IAChB,IAAI,CAAC+C,GAAG,CAAC,WAAW,EAAE/C,KAAK,CAACC,OAAO,CAAC;IACpC,IAAI,CAAC+F,iBAAiB,CAAC,CAAC;IACxB,IAAI,CAACnG,oBAAoB,CAACG,KAAK,CAACsE,OAAO,CAAExD,QAAQ,IAAKA,QAAQ,CAACd,KAAK,CAAC,CAAC;EAC1E;EACA;EACAgG,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAACjH,QAAQ,CAACuF,OAAO,CAAE/B,OAAO,IAAKA,OAAO,CAACqD,QAAQ,CAAC9H,cAAc,CAACkC,KAAK,CAAC,CAAC;EAC9E;EACA;EACAuF,aAAaA,CAACW,GAAG,EAAEjH,MAAM,EAAE;IACvB,IAAIoB,MAAM,CAAC8F,IAAI,CAAClH,MAAM,CAAC,CAACyD,MAAM,KAAK,CAAC,EAAE;MAClC,OAAOwD,GAAG;IACd;IACA,MAAME,MAAM,GAAGF,GAAG,CAACG,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG;IAC1C,MAAMC,KAAK,GAAG,IAAIC,eAAe,CAACtH,MAAM,CAAC;IACzC,OAAQ,GAAEiH,GAAI,GAAEE,MAAO,GAAEE,KAAM,EAAC;EACpC;EACA;EACAT,gBAAgBA,CAAA,EAAG;IACf,IAAI,IAAI,CAAClC,WAAW,CAAC,CAAC,IAAI,IAAI,CAAChE,UAAU,CAAC+C,MAAM,GAAG,CAAC,EAAE;MAClD,IAAI,CAAC/C,UAAU,CAAC2E,OAAO,CAAExD,QAAQ,IAAKA,QAAQ,CAAC,CAAC,CAAC;MACjD,IAAI,CAACnB,UAAU,GAAG,EAAE;IACxB;EACJ;EACA;EACAoG,cAAcA,CAAA,EAAG;IACb,IAAIlH,EAAE;IACN,IAAI,CAAC,IAAI,CAAC8E,WAAW,CAAC,CAAC,EAAE;MACrB;IACJ;IACA,IAAI,IAAI,CAACpE,mBAAmB,EAAE;MAC1B,IAAI,CAACA,mBAAmB,GAAG,IAAI;MAC/B,IAAI,CAACwD,GAAG,CAAC,WAAW,EAAE,0DAA0D,CAAC;MACjF,CAAClE,EAAE,GAAG,IAAI,CAACa,IAAI,MAAM,IAAI,IAAIb,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACkB,KAAK,CAAC7B,eAAe,EAAE,kBAAkB,CAAC;MACnG;IACJ;IACA,IAAI,CAACqB,mBAAmB,GAAG,IAAI,CAACqF,QAAQ,CAAC,CAAC;IAC1C,IAAI,CAACb,IAAI,CAAC;MACNH,KAAK,EAAE,SAAS;MAChB/B,KAAK,EAAE,WAAW;MAClBhB,OAAO,EAAE,CAAC,CAAC;MACXrB,GAAG,EAAE,IAAI,CAACD;IACd,CAAC,CAAC;IACF,IAAI,CAAC6E,OAAO,CAAC,IAAI,CAACtF,WAAW,CAAC;EAClC;EACA;EACAqF,SAASA,CAACrD,QAAQ,EAAEZ,sBAAsB,GAAG,IAAI,CAACA,sBAAsB,EAAE;IACtE,OAAO,MAAM;MACT,IAAI,IAAI,CAACC,UAAU,EACf,OAAO,IAAI;MACfW,QAAQ,CAAC,CAAC;MACV,IAAIZ,sBAAsB,GAAG,CAAC,EAAE;QAC5B,IAAI,CAACC,UAAU,GAAG,IAAI;QACtBqG,UAAU,CAAC,MAAM;UACb,IAAI,CAACrG,UAAU,GAAG,KAAK;QAC3B,CAAC,EAAED,sBAAsB,CAAC;MAC9B;MACA,OAAO,KAAK;IAChB,CAAC;EACL;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}